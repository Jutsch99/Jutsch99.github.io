<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Yen-Gar ‚Ä¢ Test Build 1 (Landscape Top-Level)</title>
<style>
  :root{
    /* ===== Overlay alignment tuned to your board image =====
       These % values place the Top Level (T1..T15) over the yellow band. */
    --top-x: 22;        /* left % */
    --top-y: 7.5;       /* top %  */
    --top-w: 56;        /* width % covering all T tiles */
    --top-h: 9.5;       /* height % of yellow band      */

    /* Look/feel */
    --piece-size: clamp(40px, 7vmin, 80px);   /* bigger pieces by default */
    --line-gap: 10px;
    --max-width: 1400px;
    --header-h: 54px;                         /* used for landscape sizing */
  }

  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; background:#0e0f13; color:#fafafa; font:16px/1.4 system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
    -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
    touch-action: manipulation;
  }

  header{
    position:sticky; top:0; z-index:50; background:#10131a;
    border-bottom:1px solid #2a3142; padding:10px 12px; display:flex; align-items:center; gap:10px; justify-content:center;
    height: var(--header-h);
  }
  .title{opacity:.9}
  .btn{
    appearance:none; border:1px solid #3b445a; background:#161b26; color:#e9eefc;
    padding:8px 12px; border-radius:10px; cursor:pointer; font-weight:600;
    box-shadow:0 1px 0 rgba(255,255,255,.05) inset, 0 6px 18px rgba(0,0,0,.25);
  }
  .btn:active{transform:translateY(1px)}
  .btn.primary{background:#1f2a44; border-color:#4a72ff}
  .dice{ min-width:72px; text-align:center; font-variant-numeric:tabular-nums;
    background:#0f1422; padding:6px 12px; border-radius:10px; border:1px solid #2a3142; }
  .rightbar{ position:absolute; right:12px; top:8px; display:flex; gap:10px; }

  .wrap{
    margin:10px auto; display:grid; grid-template-columns: minmax(0,1fr);
    max-width:var(--max-width); width:100%; gap:12px; padding:0 10px;
  }

  /* Board scales to fit landscape height for ‚Äúphone held horizontally‚Äù play */
  .board-box{
    position:relative; width:100%;
    aspect-ratio: 16 / 10; /* updated to real ratio after image loads */
    background:#0a0c12; border-radius:14px; overflow:hidden; border:1px solid #2a3142;
    margin: 0 auto;
  }
  .board{
    position:absolute; inset:0; width:100%; height:100%; object-fit:contain;
    user-select:none; -webkit-user-drag:none; pointer-events:none;
  }

  .overlay{ position:absolute; inset:0; pointer-events:none; }
  .tile{ position:absolute; outline:1px dashed rgba(255,255,255,.08); border-radius:4px; pointer-events:auto; }

  /* Top-line spawn rail (inside the board, along its top edge) */
  .spawn-rail{
    position:absolute; left:0; right:0; top:0;
    height: calc(var(--piece-size) + 12px);
    pointer-events:none;
  }

  .piece{
    width:var(--piece-size); height:var(--piece-size);
    border-radius:50%; position:absolute; left:0; top:0;
    transform:translate(-50%,-50%); touch-action:none; user-select:none; -webkit-user-drag:none;
    cursor:grab; pointer-events:auto; z-index:5; box-shadow:0 4px 14px rgba(0,0,0,.45);
    transition: box-shadow .12s ease;
  }
  .piece:active{ cursor:grabbing; box-shadow:0 6px 18px rgba(0,0,0,.6) }
  .fade-out{ animation: fade .33s ease forwards }
  @keyframes fade{ to{ opacity:0; transform:translate(-50%,-50%) scale(.6) } }

  @media (orientation:landscape){
    /* Fill the landscape height nicely (minus header) */
    .wrap { max-width: 100vw; }
    .board-box{
      max-height: calc(100svh - var(--header-h) - 16px);
      margin: 0 auto;
    }
  }
  @media (max-width:720px){ .rightbar{ position:static; justify-content:center } }
</style>
</head>
<body>
  <header>
    <span class="title">Yen-Gar ‚Ä¢ Test Build</span>
    <button id="diceBtn" class="btn primary">üé≤ Dice</button>
    <div id="diceVal" class="dice">‚Äî</div>
    <div class="rightbar">
      <button id="resetBtn" class="btn">Reset board</button>
    </div>
  </header>

  <div class="wrap">
    <div class="board-box" id="boardBox">
      <img id="boardImg" class="board" src="board.png" alt="Yen-Gar Board" />
      <div class="overlay" id="overlay"></div>
      <div class="spawn-rail" id="spawnRail"></div>
    </div>
  </div>

<script>
/* ========== Assets (use your existing filenames) ========== */
const WALL_STYLE = 'black';
const SPRITES = {
  KingQueen: "king.png",
  Purple:    "purple.png",
  Special:   "special.png",
  Red:       "red.png",
  Green:     "green.png",
  Blue:      "blue.png",
  Yellow:    "yellow.png",
  TopDisc:   "topdisc.png",
  Wall:      (WALL_STYLE === 'white') ? "wall-white.png" : "wall-black.png",
  Spawner:   "spawner.png"
};

/* ========== DOM refs ========== */
const boardBox = document.getElementById('boardBox');
const boardImg = document.getElementById('boardImg');
const overlay  = document.getElementById('overlay');
const spawnRail= document.getElementById('spawnRail');
const diceBtn  = document.getElementById('diceBtn');
const diceVal  = document.getElementById('diceVal');
const resetBtn = document.getElementById('resetBtn');

/* Keep the board‚Äôs aspect ratio from the image and size for landscape height */
let boardNatural = { w:1600, h:1000 };
function sizeBoardBox(){
  const w = boardNatural.w, h = boardNatural.h;
  boardBox.style.aspectRatio = `${w} / ${h}`;

  // In landscape, prefer fitting height (minus header) while respecting width
  const headerH = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--header-h')) || 54;
  const availH = Math.max(0, (window.innerHeight || 0) - headerH - 16); // padding
  const fitW = availH * (w / h);
  const maxW = document.querySelector('.wrap').clientWidth;

  const finalW = Math.min(maxW, fitW);
  boardBox.style.width  = finalW + 'px';
  boardBox.style.height = (finalW * (h / w)) + 'px';
}

boardImg.addEventListener('load', () => {
  boardNatural.w = boardImg.naturalWidth  || boardNatural.w;
  boardNatural.h = boardImg.naturalHeight || boardNatural.h;
  sizeBoardBox();
});
window.addEventListener('resize', sizeBoardBox, {passive:true});

/* ========== Tiles: ONLY Top Level (T1..T15) ========== */
const tiles = [];
function getVar(n){return parseFloat(getComputedStyle(document.documentElement).getPropertyValue(n))||0;}
function pct(n){return n+'%';}

function buildTiles(){
  tiles.length=0;
  const tx=+getVar('--top-x'), ty=+getVar('--top-y'), tw=+getVar('--top-w'), th=+getVar('--top-h');
  for(let i=0;i<15;i++){
    tiles.push({id:'T'+(i+1), topLevel:true, x:tx+tw/15*i, y:ty, w:tw/15, h:th});
  }
}

const tileEls=new Map();
function renderOverlay(){
  overlay.innerHTML=''; tileEls.clear();
  for(const t of tiles){
    const el=document.createElement('div');
    el.className='tile';
    el.dataset.id=t.id;
    el.style.left=pct(t.x); el.style.top=pct(t.y); el.style.width=pct(t.w); el.style.height=pct(t.h);
    overlay.appendChild(el);
    tileEls.set(t.id, el);
  }
}

/* ========== Pieces ========== */
const START_SET = [
  {type:'KingQueen', count:2},
  {type:'Purple',    count:1},
  {type:'Special',   count:1},
  {type:'Red',       count:8},
  {type:'Green',     count:2},
  {type:'Blue',      count:4},
  {type:'Yellow',    count:4},
  {type:'TopDisc',   count:3},
  {type:'Wall',      count:4},
  {type:'Spawner',   count:1}
];

let pieces = [];
let initialSnapshot = null;

/* lay out a single horizontal line along the very top of the board */
function layoutTopLine(){
  const bb = boardBox.getBoundingClientRect();
  const rail = spawnRail.getBoundingClientRect();
  const piece = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--piece-size'))||64;
  const gap   = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--line-gap'))||10;

  let x = piece/2 + 8;             // left margin inside board
  const y = Math.max(rail.top - bb.top, 0) + piece/2 + 6; // just inside the top

  return {
    next(){
      const pos = { x, y };
      x += (piece + gap);
      // If we run out of width, wrap to a second line just beneath (rare)
      if (x + piece/2 > bb.width - 8){
        x = piece/2 + 8;
      }
      return pos;
    }
  };
}

function createPieces(){
  pieces = [];
  const posGen = layoutTopLine();
  // Keep two sides but line everything into one top row
  for(const side of ['P1','P2']){
    for(const it of START_SET){
      for(let i=0;i<it.count;i++){
        const el = document.createElement('img');
        el.draggable = false; el.className = 'piece';
        el.alt = `${side} ${it.type}`;
        el.src = SPRITES[it.type] || SPRITES.Red;
        const p = { el, type:it.type, side, tileId:null, x:0, y:0 };
        pieces.push(p);
        boardBox.appendChild(el);
        const pos = posGen.next();
        setPiecePos(p, pos.x, pos.y);
        enableDrag(p);
      }
    }
  }
}

function setPiecePos(p, x, y){ p.x = x; p.y = y; p.el.style.left = x + 'px'; p.el.style.top = y + 'px'; }

let drag = null;
function enableDrag(p){
  p.el.addEventListener('pointerdown', (ev)=>{
    p.el.setPointerCapture(ev.pointerId);
    drag = { p, dx: ev.clientX - p.x, dy: ev.clientY - p.y };
    p.el.style.zIndex = 20;
  });
  window.addEventListener('pointermove', (ev)=>{
    if(!drag) return;
    setPiecePos(drag.p, ev.clientX - drag.dx, ev.clientY - drag.dy);
  }, {passive:true});
  window.addEventListener('pointerup', ()=>{
    if(!drag) return;
    const nearest = findNearestTopTile(drag.p);
    if(nearest){
      const occupied = findPieceOnTile(nearest.id, drag.p);
      snapPieceToTile(drag.p, nearest);
      ping(600, 0.03);
      if(occupied){
        occupied.el.classList.add('fade-out');
        setTimeout(()=>{ occupied.el.remove(); pieces = pieces.filter(q=>q!==occupied); }, 330);
        ping(220, 0.06);
      }
    }
    drag.p.el.style.zIndex = 5;
    drag = null;
  });
}

function findNearestTopTile(p){
  const bb = boardBox.getBoundingClientRect();
  const xPct = (p.x / bb.width) * 100;
  const yPct = (p.y / bb.height)* 100;
  let best=null, bestD=1e9;
  for(const t of tiles){ // tiles are only T1..T15 now
    const cx = t.x + t.w/2, cy = t.y + t.h/2;
    const d2 = (xPct-cx)**2 + (yPct-cy)**2;
    if(d2 < bestD){ bestD = d2; best = t; }
  }
  return best;
}
function findPieceOnTile(tileId, exclude){ return pieces.find(p => p.tileId === tileId && p !== exclude); }

function snapPieceToTile(p, t){
  const bb = boardBox.getBoundingClientRect();
  const cx = (t.x + t.w/2)/100 * bb.width;
  const cy = (t.y + t.h/2)/100 * bb.height;
  setPiecePos(p, cx, cy);
  p.tileId = t.id;
}

/* Dice + Reset */
diceBtn.addEventListener('click', ()=>{ diceVal.textContent = 1 + Math.floor(Math.random()*6); });

function snapshotInitial(){ initialSnapshot = pieces.map(p => ({type:p.type, side:p.side})); }

function resetBoard(){
  for(const p of pieces){ p.el.remove(); } pieces.length = 0;
  if(!initialSnapshot){ createPieces(); snapshotInitial(); diceVal.textContent='‚Äî'; return; }

  const posGen = layoutTopLine();
  for(const spec of initialSnapshot){
    const el = document.createElement('img');
    el.draggable = false; el.className = 'piece';
    el.alt = `${spec.side} ${spec.type}`;
    el.src = SPRITES[spec.type] || SPRITES.Red;
    const p = { el, type:spec.type, side:spec.side, tileId:null, x:0, y:0 };
    pieces.push(p); boardBox.appendChild(el);
    const pos = posGen.next();
    setPiecePos(p, pos.x, pos.y); enableDrag(p);
  }
  diceVal.textContent = '‚Äî';
}
resetBtn.addEventListener('click', resetBoard);

/* Init */
function init(){
  buildTiles(); renderOverlay();
  createPieces(); snapshotInitial();
  sizeBoardBox();
}
init();

/* Tiny feedback ping */
let AC = null;
function ping(freq=600, dur=0.04){
  try{
    AC = AC || new (window.AudioContext||window.webkitAudioContext)();
    const ctx = AC, o = ctx.createOscillator(), g = ctx.createGain();
    o.type = 'square'; o.frequency.value = freq;
    g.gain.value = 0.09;
    o.connect(g); g.connect(ctx.destination);
    const t = ctx.currentTime;
    o.start(t);
    g.gain.exponentialRampToValueAtTime(0.0001, t + dur);
    o.stop(t + dur + 0.01);
  }catch(e){}
}
</script>
</body>
</html>