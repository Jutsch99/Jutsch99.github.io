<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Yen-Gar â€¢ Auto-detect T1â€“T15 (Landscape)</title>
<style>
  :root{
    --piece-size: clamp(44px, 7.5vmin, 86px);
    --line-gap: 12px;
    --header-h: 54px;
    --max-width: 1400px;
    /* Fallback if auto-detect is blocked: rough guess you can tweak or calibrate */
    --top-x: 22;      /* % from left */
    --top-y: 7.5;     /* % from top  */
    --top-w: 56;      /* % width     */
    --top-h: 9.5;     /* % height    */
  }

  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; background:#0e0f13; color:#f3f6ff; font:16px/1.4 system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
    -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
    touch-action: manipulation;
  }

  header{
    position:sticky; top:0; z-index:20; height:var(--header-h);
    display:flex; align-items:center; justify-content:center; gap:10px;
    background:#10131a; border-bottom:1px solid #2a3142; padding:8px 12px;
  }
  .btn{
    appearance:none; border:1px solid #3b445a; background:#161b26; color:#e9eefc;
    padding:8px 12px; border-radius:10px; cursor:pointer; font-weight:600;
    box-shadow:0 1px 0 rgba(255,255,255,.05) inset, 0 6px 18px rgba(0,0,0,.25);
  }
  .btn.primary{background:#1f2a44; border-color:#4a72ff}
  .dice{ min-width:72px; text-align:center; font-variant-numeric:tabular-nums;
    background:#0f1422; padding:6px 12px; border-radius:10px; border:1px solid #2a3142; }
  .rightbar{ position:absolute; right:12px; top:8px; display:flex; gap:8px; }

  .wrap{ margin:10px auto; max-width:var(--max-width); padding:0 10px; }
  .board-box{
    position:relative; width:100%; margin:0 auto;
    aspect-ratio: 16 / 10; /* updated after image load */
    background:#0a0c12; border-radius:14px; overflow:hidden; border:1px solid #2a3142;
  }
  .board{
    position:absolute; inset:0; width:100%; height:100%; object-fit:contain;
    user-select:none; -webkit-user-drag:none; pointer-events:none;
  }
  .overlay{ position:absolute; inset:0; pointer-events:none; }
  .tile{
    position:absolute; border-radius:4px; pointer-events:none;
    outline:1px dashed rgba(255,255,255,.0); /* visible in calibrate mode */
  }

  .spawn-rail{
    position:absolute; left:0; right:0; top:0;
    height: calc(var(--piece-size) + 12px);
    pointer-events:none;
  }

  .piece{
    width:var(--piece-size); height:var(--piece-size);
    border-radius:50%; position:absolute; left:0; top:0;
    transform:translate(-50%,-50%); touch-action:none; user-select:none; -webkit-user-drag:none;
    cursor:grab; pointer-events:auto; z-index:5; box-shadow:0 4px 14px rgba(0,0,0,.45);
    transition: box-shadow .12s ease;
  }
  .piece:active{ cursor:grabbing; box-shadow:0 6px 18px rgba(0,0,0,.6) }
  .fade-out{ animation: fade .33s ease forwards }
  @keyframes fade{ to{ opacity:0; transform:translate(-50%,-50%) scale(.6) } }

  @media (orientation:landscape){
    .wrap { max-width: 100vw; }
    .board-box{
      max-height: calc(100svh - var(--header-h) - 16px);
    }
  }

  /* ===== Calibrate mode ===== */
  .cal-info{
    position:absolute; left:10px; top:10px; z-index:30;
    background:rgba(0,0,0,.55); backdrop-filter: blur(4px);
    padding:6px 10px; border-radius:8px; font-size:13px; border:1px solid rgba(255,255,255,.12);
  }
  .cal-box{ position:absolute; border:2px dashed rgba(255,255,255,.8); border-radius:6px; pointer-events:none; }
  .cal-handle{
    position:absolute; width:16px; height:16px;
    background:#fff; border-radius:4px; border:1px solid #000;
    box-shadow:0 2px 8px rgba(0,0,0,.35);
    transform:translate(-50%,-50%); cursor:grab; pointer-events:auto;
  }
  .calibrating .tile{ outline-color: rgba(255,255,255,.25); }
</style>
</head>
<body>
  <header>
    <span class="title">Yen-Gar â€¢ Top Row Autoâ€‘Detect</span>
    <button id="diceBtn" class="btn primary">ðŸŽ² Dice</button>
    <div id="diceVal" class="dice">â€”</div>
    <div class="rightbar">
      <button id="calBtn" class="btn" title="Adjust the yellow band if needed">Calibrate</button>
      <button id="resetBtn" class="btn">Reset board</button>
    </div>
  </header>

  <div class="wrap">
    <div class="board-box" id="boardBox">
      <img id="boardImg" class="board" alt="Yen-Gar Board" />
      <div class="overlay" id="overlay"></div>
      <div class="spawn-rail" id="spawnRail"></div>

      <!-- Calibrate UI (created dynamically) -->
    </div>
  </div>

<script>
/* ========= Assets (use your exact filenames) ========= */
const SPRITES = {
  KingQueen: "King:Queen sprite.PNG",
  Purple:    "Purple sprite.PNG",
  Special:   "Special Disc sprite.PNG",
  Red:       "Red (Attacker) sprite.PNG",
  Green:     " Green (Midfielder) sprite.PNG",
  Blue:      "Blue (Defender) sprite.PNG",
  Yellow:    "Yellow (Minion) sprite.PNG",
  TopDisc:   "Top Disc sprite .PNG",
  Wall:      "black wall sprite.PNG",
  Spawner:   "Spawner sprite.PNG"
};

/* ========= DOM ========= */
const boardBox = document.getElementById('boardBox');
const boardImg = document.getElementById('boardImg');
const overlay  = document.getElementById('overlay');
const spawnRail= document.getElementById('spawnRail');
const diceBtn  = document.getElementById('diceBtn');
const diceVal  = document.getElementById('diceVal');
const resetBtn = document.getElementById('resetBtn');
const calBtn   = document.getElementById('calBtn');

/* Load the board image with fallback */
(function loadBoard(){
  const try1 = "Yen-Gar Game Board finished.png";
  const try2 = "board.png";
  boardImg.crossOrigin = "anonymous"; // allow pixel read when hosted
  boardImg.src = try1;
  boardImg.onerror = () => { if (!boardImg.src.endsWith(try2)) boardImg.src = try2; };
})();

/* Maintain proper aspect */
let boardNatural = { w:1600, h:1000 };
function sizeBoardBox(){
  const w = boardNatural.w, h = boardNatural.h;
  boardBox.style.aspectRatio = `${w} / ${h}`;

  const headerH = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--header-h')) || 54;
  const availH = Math.max(0, (window.innerHeight || 0) - headerH - 16);
  const fitW = availH * (w / h);
  const maxW = document.querySelector('.wrap').clientWidth;
  const finalW = Math.min(maxW, fitW);
  boardBox.style.width  = finalW + 'px';
  boardBox.style.height = (finalW * (h / w)) + 'px';
}
window.addEventListener('resize', sizeBoardBox, {passive:true});

/* ========= Auto-detect the yellow top band ========= */
let tRowRect = null; // in percentages: {x,y,w,h}
const LS_KEY = 'yengar.trow.rect.v1';

function loadSavedRect(){
  try{
    const s = localStorage.getItem(LS_KEY);
    if(!s) return null;
    const r = JSON.parse(s);
    if(['x','y','w','h'].every(k => typeof r[k] === 'number')) return r;
  }catch(e){}
  return null;
}
function saveRect(r){ try{ localStorage.setItem(LS_KEY, JSON.stringify(r)); }catch(e){} }

function rgb2hsv(r,g,b){
  r/=255; g/=255; b/=255;
  const max = Math.max(r,g,b), min = Math.min(r,g,b);
  const d = max-min;
  let h=0, s = max===0?0:d/max, v = max;
  if(d!==0){
    switch(max){
      case r: h = (g-b)/d + (g<b?6:0); break;
      case g: h = (b-r)/d + 2; break;
      case b: h = (r-g)/d + 4; break;
    }
    h/=6;
  }
  return {h,s,v};
}
function isYellow(r,g,b){
  const {h,s,v} = rgb2hsv(r,g,b);      // h in [0,1]
  const deg = h*360;
  return (deg >= 40 && deg <= 65) && s >= 0.4 && v >= 0.55;
}

async function detectTopBand(img){
  // Draw to canvas same size as image
  const w = img.naturalWidth, h = img.naturalHeight;
  const cnv = document.createElement('canvas');
  cnv.width = w; cnv.height = h;
  const ct = cnv.getContext('2d', { willReadFrequently:true });
  ct.drawImage(img,0,0);
  let data;
  try{
    data = ct.getImageData(0,0,w,h).data;
  }catch(e){
    // cross-origin blocked: gracefully fall back to CSS vars or saved rect
    return null;
  }

  // Scan only the top 35% of rows; build yellow density by row (with stride for perf)
  const yMax = Math.floor(h*0.35);
  const xStride = Math.max(1, Math.floor(w/800));
  const yStride = Math.max(1, Math.floor(h/800));

  const rowFrac = new Float32Array(yMax);
  const lefts = new Int32Array(yMax).fill(-1);
  const rights= new Int32Array(yMax).fill(-1);

  for(let y=0; y<yMax; y+=yStride){
    let yellow=0, count=0, left=-1, right=-1;
    for(let x=0; x<w; x+=xStride){
      const idx = ((y*w)+x)*4;
      const r=data[idx], g=data[idx+1], b=data[idx+2];
      if(isYellow(r,g,b)){
        yellow++;
        if(left===-1) left=x;
        right=x;
      }
      count++;
    }
    rowFrac[y] = count ? yellow/count : 0;
    lefts[y] = left; rights[y] = right;
  }

  // Find the top-most longest band where yellow fraction exceeds threshold
  const THRESH = 0.12; // tolerantâ€”gaps between tiles allowed
  let bestStart=-1, bestEnd=-1, curStart=-1;
  for(let y=0; y<yMax; y+=yStride){
    if(rowFrac[y] >= THRESH){
      if(curStart===-1) curStart=y;
    }else if(curStart!==-1){
      if((bestStart===-1) || (y-curStart > bestEnd-bestStart)){ bestStart=curStart; bestEnd=y-1; }
      curStart=-1;
    }
  }
  if(curStart!==-1){
    if((bestStart===-1) || (yMax-curStart > bestEnd-bestStart)){ bestStart=curStart; bestEnd=yMax-1; }
  }
  if(bestStart===-1) return null;

  // Collect left/right edges across the band; use percentiles to ignore small gaps
  const leftVals=[], rightVals=[];
  for(let y=bestStart; y<=bestEnd; y+=yStride){
    if(lefts[y]!==-1){ leftVals.push(lefts[y]); }
    if(rights[y]!==-1){ rightVals.push(rights[y]); }
  }
  if(!leftVals.length || !rightVals.length) return null;

  leftVals.sort((a,b)=>a-b); rightVals.sort((a,b)=>a-b);
  const pct = (arr, p) => arr[Math.min(arr.length-1, Math.max(0, Math.floor(p*(arr.length-1))))];
  const left  = pct(leftVals, 0.05);
  const right = pct(rightVals, 0.95);
  const yTop  = bestStart;
  const yBot  = bestEnd;

  // Pad a hair so the box fully covers the yellow band
  const padX = Math.round(w*0.005), padY = Math.round(h*0.004);
  const x0 = Math.max(0, left - padX);
  const x1 = Math.min(w-1, right + padX);
  const y0 = Math.max(0, yTop - padY);
  const y1 = Math.min(h-1, yBot + padY);

  return {
    x: (x0 / w) * 100,
    y: (y0 / h) * 100,
    w: ((x1 - x0) / w) * 100,
    h: ((y1 - y0) / h) * 100
  };
}

/* ========= Tiles (T1..T15 only) ========= */
const tiles = [];
function pct(n){ return n+'%'; }
function buildTilesFromRect(rect){
  tiles.length=0;
  const segW = rect.w / 15;
  for(let i=0;i<15;i++){
    tiles.push({
      id:'T'+(i+1),
      x: rect.x + segW*i,
      y: rect.y,
      w: segW,
      h: rect.h
    });
  }
}
const tileEls = new Map();
function renderOverlay(show=false){
  overlay.innerHTML=''; tileEls.clear();
  for(const t of tiles){
    const el=document.createElement('div');
    el.className='tile';
    el.dataset.id=t.id;
    el.style.left=pct(t.x); el.style.top=pct(t.y); el.style.width=pct(t.w); el.style.height=pct(t.h);
    if(show) el.style.outlineColor = 'rgba(255,255,255,.25)';
    overlay.appendChild(el);
    tileEls.set(t.id, el);
  }
}

/* ========= Pieces ========= */
const START_SET = [
  {type:'KingQueen', count:2},
  {type:'Purple',    count:1},
  {type:'Special',   count:1},
  {type:'Red',       count:8},
  {type:'Green',     count:2},
  {type:'Blue',      count:4},
  {type:'Yellow',    count:4},
  {type:'TopDisc',   count:3},
  {type:'Wall',      count:4},
  {type:'Spawner',   count:1}
];

let pieces = [];
let initialSnapshot = null;

function layoutTopLine(){
  const bb = boardBox.getBoundingClientRect();
  const piece = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--piece-size'))||64;
  const leftMargin = piece/2 + 8;
  const rightMargin = piece/2 + 8;
  const usableW = Math.max(0, bb.width - leftMargin - rightMargin);
  const total = START_SET.reduce((sum, it)=> sum + it.count*2, 0);
  const step = Math.max(piece + (parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--line-gap'))||12),
                        usableW / Math.max(1,total-1));
  let x = leftMargin;
  const y = piece/2 + 6;
  return {
    next(){ const pos = {x,y}; x += step; return pos; }
  };
}
function createPieces(){
  pieces = [];
  const posGen = layoutTopLine();
  for(const side of ['P1','P2']){
    for(const it of START_SET){
      for(let i=0;i<it.count;i++){
        const el = document.createElement('img');
        el.draggable = false; el.className = 'piece';
        el.alt = `${side} ${it.type}`;
        el.src = SPRITES[it.type] || SPRITES.Red;
        const p = { el, type:it.type, side, tileId:null, x:0, y:0 };
        pieces.push(p);
        boardBox.appendChild(el);
        const pos = posGen.next();
        setPiecePos(p, pos.x, pos.y);
        enableDrag(p);
      }
    }
  }
}
function setPiecePos(p, x, y){ p.x = x; p.y = y; p.el.style.left = x + 'px'; p.el.style.top = y + 'px'; }

let drag = null;
function enableDrag(p){
  p.el.addEventListener('pointerdown', (ev)=>{
    p.el.setPointerCapture(ev.pointerId);
    drag = { p, dx: ev.clientX - p.x, dy: ev.clientY - p.y };
    p.el.style.zIndex = 20;
  });
  window.addEventListener('pointermove', (ev)=>{
    if(!drag) return;
    setPiecePos(drag.p, ev.clientX - drag.dx, ev.clientY - drag.dy);
  }, {passive:true});
  window.addEventListener('pointerup', (ev)=>{
    if(!drag) return;
    // Drop only if inside the board
    const bb = boardBox.getBoundingClientRect();
    if(ev.clientX>=bb.left && ev.clientX<=bb.right && ev.clientY>=bb.top && ev.clientY<=bb.bottom){
      const nearest = findNearestTopTile(drag.p);
      if(nearest){
        const occupied = findPieceOnTile(nearest.id, drag.p);
        snapPieceToTile(drag.p, nearest);
        ping(600, 0.03);
        if(occupied){
          occupied.el.classList.add('fade-out');
          setTimeout(()=>{ occupied.el.remove(); pieces = pieces.filter(q=>q!==occupied); }, 330);
          ping(220, 0.06);
        }
      }
    }
    drag.p.el.style.zIndex = 5;
    drag = null;
  });
}
function findNearestTopTile(p){
  const bb = boardBox.getBoundingClientRect();
  const xPct = (p.x / bb.width) * 100;
  const yPct = (p.y / bb.height)* 100;
  let best=null, bestD=1e9;
  for(const t of tiles){ // tiles are ONLY T1..T15
    const cx = t.x + t.w/2, cy = t.y + t.h/2;
    const d2 = (xPct-cx)**2 + (yPct-cy)**2;
    if(d2 < bestD){ bestD = d2; best = t; }
  }
  return best;
}
function findPieceOnTile(tileId, exclude){ return pieces.find(p => p.tileId === tileId && p !== exclude); }
function snapPieceToTile(p, t){
  const bb = boardBox.getBoundingClientRect();
  const cx = (t.x + t.w/2)/100 * bb.width;
  const cy = (t.y + t.h/2)/100 * bb.height;
  setPiecePos(p, cx, cy);
  p.tileId = t.id;
}

/* Dice + Reset */
diceBtn.addEventListener('click', ()=>{ diceVal.textContent = 1 + Math.floor(Math.random()*6); });
function snapshotInitial(){ initialSnapshot = pieces.map(p => ({type:p.type, side:p.side})); }
function resetBoard(){
  for(const p of pieces){ p.el.remove(); } pieces.length = 0;
  const posGen = layoutTopLine();
  const snap = initialSnapshot || [];
  for(const spec of snap){
    const el = document.createElement('img');
    el.draggable = false; el.className = 'piece';
    el.alt = `${spec.side} ${spec.type}`;
    el.src = SPRITES[spec.type] || SPRITES.Red;
    const p = { el, type:spec.type, side:spec.side, tileId:null, x:0, y:0 };
    pieces.push(p); boardBox.appendChild(el);
    const pos = posGen.next();
    setPiecePos(p, pos.x, pos.y); enableDrag(p);
  }
  diceVal.textContent = 'â€”';
}
resetBtn.addEventListener('click', resetBoard);

/* ========= Calibrate mode (optional) ========= */
let calibrating = false;
let calEl=null, hNW=null,hNE=null,hSW=null,hSE=null, boxEl=null, infoEl=null;

function ensureCalUI(){
  if(calEl) return;
  calEl = document.createElement('div');
  calEl.className = 'cal';
  boxEl = document.createElement('div'); boxEl.className='cal-box';
  hNW = document.createElement('div'); hNW.className='cal-handle'; hNW.dataset.corner='nw';
  hNE = document.createElement('div'); hNE.className='cal-handle'; hNE.dataset.corner='ne';
  hSW = document.createElement('div'); hSW.className='cal-handle'; hSW.dataset.corner='sw';
  hSE = document.createElement('div'); hSE.className='cal-handle'; hSE.dataset.corner='se';
  infoEl = document.createElement('div'); infoEl.className='cal-info';
  calEl.appendChild(boxEl); calEl.appendChild(hNW); calEl.appendChild(hNE); calEl.appendChild(hSW); calEl.appendChild(hSE); calEl.appendChild(infoEl);
  boardBox.appendChild(calEl);

  const handles=[hNW,hNE,hSW,hSE];
  let curCorner=null;
  handles.forEach(h=>{
    h.addEventListener('pointerdown',(ev)=>{
      h.setPointerCapture(ev.pointerId);
      curCorner = h.dataset.corner;
    });
  });
  window.addEventListener('pointermove',(ev)=>{
    if(!calibrating || !curCorner) return;
    const bb = boardBox.getBoundingClientRect();
    const x = ((ev.clientX - bb.left) / bb.width) * 100;
    const y = ((ev.clientY - bb.top)  / bb.height)* 100;
    const r = {...tRowRect};
    if(curCorner==='nw'){ const rx=r.x+r.w; r.x=Math.max(0,Math.min(x,rx-1)); r.y=Math.max(0,Math.min(y,r.y+r.h-1)); r.w=rx-r.x; r.h=(r.y+r.h)-r.y; }
    if(curCorner==='ne'){ const ry=r.y+r.h; r.w=Math.max(1, Math.min(100-r.x, x - r.x)); r.y=Math.max(0,Math.min(y,ry-1)); r.h=ry-r.y; }
    if(curCorner==='sw'){ const rx=r.x+r.w; r.x=Math.max(0,Math.min(x,rx-1)); r.h=Math.max(1, Math.min(100-r.y, y - r.y)); r.w=rx-r.x; }
    if(curCorner==='se'){ r.w=Math.max(1, Math.min(100-r.x, x - r.x)); r.h=Math.max(1, Math.min(100-r.y, y - r.y)); }
    tRowRect=r; applyRectToUI(); buildTilesFromRect(tRowRect); renderOverlay(true);
    infoEl.textContent = `T-row: x:${r.x.toFixed(2)}% y:${r.y.toFixed(2)}% w:${r.w.toFixed(2)}% h:${r.h.toFixed(2)}%`;
  });
  window.addEventListener('pointerup',()=>{
    if(!calibrating) return;
    curCorner=null;
    saveRect(tRowRect);
  });
}

function applyRectToUI(){
  const r = tRowRect;
  boxEl.style.left = pct(r.x); boxEl.style.top = pct(r.y); boxEl.style.width = pct(r.w); boxEl.style.height = pct(r.h);
  hNW.style.left = pct(r.x);           hNW.style.top = pct(r.y);
  hNE.style.left = pct(r.x + r.w);     hNE.style.top = pct(r.y);
  hSW.style.left = pct(r.x);           hSW.style.top = pct(r.y + r.h);
  hSE.style.left = pct(r.x + r.w);     hSE.style.top = pct(r.y + r.h);
}

calBtn.addEventListener('click', ()=>{
  calibrating = !calibrating;
  ensureCalUI();
  document.body.classList.toggle('calibrating', calibrating);
  calBtn.textContent = calibrating ? 'Done' : 'Calibrate';
  if(calibrating){
    applyRectToUI();
    renderOverlay(true);
  }else{
    renderOverlay(false);
  }
});

/* ========= Init ========= */
async function init(){
  await new Promise(res=>{
    boardImg.addEventListener('load', res, {once:true});
    // In case it was already loaded from cache:
    if(boardImg.complete) res();
  });
  boardNatural.w = boardImg.naturalWidth  || boardNatural.w;
  boardNatural.h = boardImg.naturalHeight || boardNatural.h;
  sizeBoardBox();

  // Try saved -> auto-detect -> fallback to CSS vars
  tRowRect = loadSavedRect();
  if(!tRowRect){
    tRowRect = await detectTopBand(boardImg);
  }
  if(!tRowRect){
    // Fallback to CSS custom properties (still adjustable via Calibrate)
    const cs = getComputedStyle(document.documentElement);
    tRowRect = {
      x: parseFloat(cs.getPropertyValue('--top-x'))||22,
      y: parseFloat(cs.getPropertyValue('--top-y'))||7.5,
      w: parseFloat(cs.getPropertyValue('--top-w'))||56,
      h: parseFloat(cs.getPropertyValue('--top-h'))||9.5
    };
  }

  buildTilesFromRect(tRowRect);
  renderOverlay(false);
  createPieces(); snapshotInitial();
}
init();

/* Tiny feedback ping */
let AC = null;
function ping(freq=600, dur=0.04){
  try{
    AC = AC || new (window.AudioContext||window.webkitAudioContext)();
    const ctx = AC, o = ctx.createOscillator(), g = ctx.createGain();
    o.type = 'square'; o.frequency.value = freq;
    g.gain.value = 0.09;
    o.connect(g); g.connect(ctx.destination);
    const t = ctx.currentTime;
    o.start(t);
    g.gain.exponentialRampToValueAtTime(0.0001, t + dur);
    o.stop(t + dur + 0.01);
  }catch(e){}
}
</script>
</body>
</html>